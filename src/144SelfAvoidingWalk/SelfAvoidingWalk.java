public class SelfAvoidingWalk {
    public static void main(String[] args) {

/*
модель случайных блужданий без самопересечений

собака блуждает по городу=массиву
она сама не поворачивает туда, где уже была
она может либо попасть в тупик, либо выйти=оказаться на крайних элементах массива
выход на крайнюю улицу = выход из города (это и есть её цель)
*/

        int n = 10;            //Integer.parseInt(args[0]);	//создаём массив=город n*n = прямоугольная сетка 10х10
        int trials = 1000;    //Integer.parseInt(args[1]); //кол-во экспериментов
        int deadEnds = 0;    //сколько раз зашла в тупик

        for (int t = 0; t < trials; t++) {
            boolean[][] a = new boolean[n][n];          //NB!!!! в начале каждой попытки массив инициализируется чтобы все значения были бы false!!!
                                                        //посещённые места = true, в начале все места=false, т.е пока нигде не была
            int x = n / 2, y = n / 2;                //где собака сейчас, здесь о том, что собака стартует в центре

            while (x > 0 && x < n - 1 && y > 0 && y < n - 1) {    //защита от выхода за границы массива=города
                a[x][y] = true;            //пометили, что собака здесь была
                if (a[x - 1][y] && a[x + 1][y] && a[x][y - 1] && a[x][y + 1]) {
                    //если всё это true, то собака попала в тупик
                    //=проверка, были ли уже в направлениях куда сейчас можно пойти = не попала ли в тупик
                    deadEnds++; //если в тупике, то попытка выйти из города провалилась
                    break;  //выход из цикла если попала в тупик
                }
                double r = Math.random();    //случайный выбор перемещения
                if (r < 0.25) {
                    if (!a[x + 1][y]) x++;  //если уже была в этом направлении, то просто не выполняется
                }
                else if (r < 0.50) {
                    if (!a[x - 1][y]) x--;
                } else if (r < 0.75) {
                    if (!a[x][y + 1]) y++;
                } else if (r < 1.00) {
                    if (!a[x][y - 1]) y--;
                }
            }
        }
        System.out.println(100 * deadEnds / trials + "% dead ends");    //сколько % раз зашла в тупик

    }
}
